/*
 * File: matrix_mult_3x3.v
 * Module: matrix_mult_3x3
 * FIX: Output 'c_out' is now full precision (64-bit) 
 * to handle fixed-point scaling.
 */
module matrix_mult_3x3 #(
    parameter DATA_WIDTH = 32,
    parameter M = 3,
    parameter N = 3,
    parameter P = 3
)(
    input  wire clk,
    input  wire rst,
    input  wire start,

    // Interface for Matrix A
    input  wire signed [DATA_WIDTH-1:0] a_in,
    input  wire [3:0] a_addr, // $clog2(3*3) = 4 bits
    input  wire a_wen,

    // Interface for Matrix B
    input  wire signed [DATA_WIDTH-1:0] b_in,
    input  wire [3:0] b_addr, // $clog2(3*3) = 4 bits
    input  wire b_wen,

    // Output Interface
    // FIX: Output is now wide enough for the accumulator
    output reg signed [2*DATA_WIDTH + $clog2(N) - 1:0] c_out, 
    output reg c_valid,
    output reg done,
    
    // Outputs to help the FSM track state
    output reg [1:0] row, // $clog2(M) = 2 bits
    output reg [1:0] col  // $clog2(P) = 2 bits
);

    localparam MAT_A_SIZE = M*N;
    localparam MAT_B_SIZE = N*P;
    localparam ACC_WIDTH = (2*DATA_WIDTH) + $clog2(N); 

    reg signed [DATA_WIDTH-1:0] A [0:MAT_A_SIZE-1];
    reg signed [DATA_WIDTH-1:0] B [0:MAT_B_SIZE-1];
    
    reg [1:0] k_count; // $clog2(N) = 2 bits
    
    reg signed [ACC_WIDTH-1:0] accumulator;

    localparam S_IDLE      = 3'd0;
    localparam S_COMPUTE   = 3'd1;
    localparam S_ACC_FINAL = 3'd2; 
    localparam S_OUTPUT    = 3'd3;
    localparam S_DONE      = 3'd4;
    reg [2:0] state;

    wire signed [2*DATA_WIDTH-1:0] product;
    assign product = $signed(A[row*N + k_count]) * $signed(B[k_count*P + col]);

    // Memory write logic
    always @(posedge clk) begin
        if (a_wen) A[a_addr] <= a_in;
        if (b_wen) B[b_addr] <= b_in;
    end

    // FSM output latches
    always @(posedge clk) begin
        if(rst) begin
            c_row <= 0;
            c_col <= 0;
        end else if (state == S_OUTPUT) begin
            c_row <= row;
            c_col <= col;
        end
    end

    // Main FSM logic
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            state <= S_IDLE;
            row <= 0;
            col <= 0;
            k_count <= 0;
            accumulator <= 0;
            c_valid <= 0;
            done <= 0;
            c_out <= 0;
        end else begin
            c_valid <= 0; // c_valid is only high for one cycle
            done <= 0;    // done is only high for one cycle

            case (state)
                S_IDLE: begin
                    if (start) begin
                        row <= 0;
                        col <= 0;
                        k_count <= 0;
                        accumulator <= 0;
                        state <= S_COMPUTE;
                    end
                end
                
                S_COMPUTE: begin
                    accumulator <= accumulator + product;
                    if (k_count == N-1) begin
                        k_count <= 0;
                        state <= S_ACC_FINAL; // Done accumulating for this cell
                    end else begin
                        k_count <= k_count + 1;
                    end
                end

                S_ACC_FINAL: begin
                    state <= S_OUTPUT;
                end
                
                S_OUTPUT: begin
                    c_out <= accumulator; // FIX: Output the full 66-bit value
                    c_valid <= 1;
                    accumulator <= 0; // Reset for next cell
                    
                    if (col == P-1) begin
                        col <= 0;
                        if (row == M-1) begin
                            state <= S_DONE; // Finished all rows
                        end else begin
                            row <= row + 1;
                            state <= S_COMPUTE; // Next row
                        end
                    end else begin
                        col <= col + 1;
                        state <= S_COMPUTE; // Next column
                    end
                end
                
                S_DONE: begin
                    done <= 1;
                    state <= S_IDLE;
                end
                
                default: state <= S_IDLE;
            endcase
        end
    end
endmodule
